#!/usr/bin/env python3

#############################################################################
##
##  This file is part of GAP, a system for computational discrete algebra.
##
##  Copyright of GAP belongs to its developers, whose names are too numerous
##  to list here. Please refer to the COPYRIGHT file for details.
##
##  SPDX-License-Identifier: GPL-2.0-or-later
##

# Run this script on main branch with data and gh-pages worktree

"""
This script compares the current test-status.json with a previous version,
and generates a main report.md along with a test-status-diff.json.
"""

import io
import json
import os
import sys

from typing import Any, Dict, List

from utils import error

################################################################################
# Arguments and Paths
num_args = len(sys.argv)

if num_args <= 1 or num_args > 3:
    error("Unknown number of arguments")

# relative paths to report directories from root
root = "data/reports"
os.makedirs(root, exist_ok=True)
dir_last_report_rel = "latest-master"

if num_args > 1:
    dir_report_rel = sys.argv[1]
if num_args > 2:
    dir_last_report_rel = sys.argv[2]

dir_report = os.path.join(root, dir_report_rel)
dir_last_report_symbolic = os.path.join(root, dir_last_report_rel)
dir_last_report = os.path.realpath(dir_last_report_symbolic)

report_path = os.path.join(dir_report, "test-status.json")
last_report_path = os.path.join(dir_last_report, "test-status.json")

################################################################################
# Read current and previous test-status
with open(report_path, "r") as f:
    report = json.load(f)

if os.path.isfile(last_report_path):
    with open(last_report_path, "r") as f:
        last_report = json.load(f)
else:  # deal with the first run of this script
    last_report = {"pkgs": {}, "id": "NULL"}

repo = report["repo"]

################################################################################
# Generate report.md and test-status-diff.json
report_diff = {}
report_diff["current"] = report["id"]
report_diff["last"] = last_report["id"]
report_diff["total"] = report["total"]
report_diff["failure"] = report["failure"]
report_diff["success"] = report["success"]
report_diff["skipped"] = report["skipped"]

################################################################################
# Package Dictionaries
pkgs = report["pkgs"]
last_pkgs = last_report["pkgs"]
pkgs_new = pkgs.keys() - last_pkgs.keys()
pkgs_removed = last_pkgs.keys() - pkgs.keys()
status_list = ["failure", "success", "skipped"]

pkgs_changed = {}
for status in status_list:
    pkgs_changed[status] = [
        pkg
        for pkg in pkgs.keys()
        if pkg in last_pkgs.keys()
        and pkgs[pkg]["status"] != last_pkgs[pkg]["status"]
        and pkgs[pkg]["status"] == status
    ]

pkgs_same = {}
for status in status_list:
    pkgs_same[status] = [
        pkg
        for pkg in pkgs.keys()
        if pkg in last_pkgs.keys()
        and pkgs[pkg]["status"] == last_pkgs[pkg]["status"]
        and pkgs[pkg]["status"] == status
    ]


def write_details_list(
    f: io.TextIOWrapper, pkgnames: List[str], pkgs: Dict[str, Any]
) -> None:
    if len(pkgnames) > 2:
        # the extra newline after </summary> is needed so that GitHub's MarkDown
        # renderer converts the Markdown list afterwards into HTML
        f.write("<details><summary>Click to show packages!</summary>\n\n")
    for pkg in sorted(pkgnames):
        version = pkgs[pkg]["version"]
        status = pkgs[pkg]["status"]
        run = pkgs[pkg]["workflow_run"]
        f.write(f"- {pkg} {version} [({status})]({run})\n")
    if len(pkgnames) > 2:
        f.write("</details>\n")
    f.write("\n")


with open(dir_report + "/report.md", "w") as f:
    ############################################################################
    # Header
    f.write(f"# Package Evaluation Report for GAP `{report['gap_version']}`\n\n")
    f.write("## Job Properties\n\n")
    f.write(
        "*Testing:* [%s](%s) vs [%s](%s)\n\n"
        % (
            report_diff["current"],
            os.path.join(repo, "blob", root, report_diff["current"]),
            report_diff["last"],
            os.path.join(repo, "blob", root, report_diff["last"]),
        )
    )
    f.write(f'*Generated by Workflow:* {report["workflow"]}\n\n')
    f.write(
        "In total, %d packages were tested, out of which %d succeeded, %d failed and %d were skipped.\n\n"
        % (report["total"], report["success"], report["failure"], report["skipped"])
    )
    if len(pkgs_changed["failure"]) > 0:
        f.write(
            ":bangbang: **Detected package(s) failing only on current version.** :bangbang:\n\n"
        )

    ############################################################################
    # New Packages
    report_diff["new"] = len(pkgs_new)
    if len(pkgs_new) > 0:
        f.write("## New Packages\n\n")
        write_details_list(f, pkgs_new, pkgs)

    ############################################################################
    # Removed Packages
    report_diff["removed"] = len(pkgs_removed)
    if len(pkgs_removed) > 0:
        f.write("## Removed Packages\n\n")
        write_details_list(f, pkgs_removed, last_pkgs)

    ############################################################################
    # Changed Status Packages
    for status, status_msg, status_header in [
        ("failure", "failed", ":exclamation: :exclamation: Packages now failing"),
        (
            "success",
            "succeeded",
            ":heavy_check_mark: :heavy_check_mark: Packages now succeeding",
        ),
        (
            "skipped",
            "skipped",
            ":heavy_multiplication_x: :heavy_multiplication_x: Packages that now skipped",
        ),
    ]:

        pkgs_filtered = pkgs_changed[status]
        report_diff[status + "_changed"] = len(pkgs_filtered)
        if len(pkgs_filtered) > 0:
            f.write(f"## {status_header}\n\n")
            f.write(
                f"{len(pkgs_filtered)} package(s) {status_msg} tests only on the current version.\n"
            )
            if len(pkgs_filtered) > 2:
                f.write("<details><summary>Click to show packages!</summary>\n\n")
            for pkg in sorted(pkgs_filtered):
                version = pkgs[pkg]["version"]
                run = pkgs[pkg]["workflow_run"]
                last_status = last_pkgs[pkg]["status"]
                last_version = last_pkgs[pkg]["version"]
                last_run = last_pkgs[pkg]["workflow_run"]
                f.write(
                    f"- {pkg} {version} [({status})]({run}) vs {pkg} {last_version} [({last_status})]({last_run})\n"
                )
            if len(pkgs_filtered) > 2:
                f.write("</details>\n")
            f.write("\n")

    ############################################################################
    # Same Status Packages
    for status, status_msg, status_header in [
        ("failure", "failed", ":exclamation: Packages still failing"),
        ("success", "succeeded", ":heavy_check_mark: Packages still succeeding"),
        ("skipped", "skipped", ":heavy_minus_sign: Packages that were skipped"),
    ]:

        pkgs_filtered = pkgs_same[status]
        report_diff[status + "_same"] = len(pkgs_filtered)
        if len(pkgs_filtered) > 0:
            f.write(f"## {status_header}\n\n")
            f.write(
                f"{len(pkgs_filtered)} package(s) {status_msg} tests also on the previous version.\n"
            )
            write_details_list(f, pkgs_filtered, pkgs)

# Write test-status-diff.json
with open(dir_report + "/test-status-diff.json", "w") as f:
    json.dump(report_diff, f, ensure_ascii=False, indent=2)
    f.write("\n")
