#!/usr/bin/env python3

#############################################################################
##
##  This file is part of GAP, a system for computational discrete algebra.
##
##  Copyright of GAP belongs to its developers, whose names are too numerous
##  to list here. Please refer to the COPYRIGHT file for details.
##
##  SPDX-License-Identifier: GPL-2.0-or-later
##

# Run this script on main branch with data and gh-pages worktree

"""
This script compares the current test-status.json with a previous version,
generates a main report.md along with
    a test-status-diff.json,
    a html-redirect, and
    a badge.
"""

from utils import warning, error, symlink, string_to_bool

import sys
import os
import glob
import json
from datetime import datetime

################################################################################
# Arguments and Paths
num_args = len(sys.argv)

if num_args < 1 or num_args > 4:
    error('Unknown number of arguments')

# relative paths to report directories from ROOT
ROOT = 'data/reports'
os.makedirs(ROOT, exist_ok = True)
DIR_LAST_REPORT_REL = 'latest'
OVERRIDE_LAST = True

if num_args > 1: DIR_REPORT_REL = sys.argv[1]
if num_args > 2: DIR_LAST_REPORT_REL = sys.argv[2]
if num_args > 3: OVERRIDE_LAST = string_to_bool(sys.argv[3])

DIR_REPORT = os.path.realpath(os.path.join(ROOT, DIR_REPORT_REL))
DIR_LAST_REPORT_SYMBOLIC = os.path.join(ROOT, DIR_LAST_REPORT_REL)
DIR_LAST_REPORT = os.path.realpath(DIR_LAST_REPORT_SYMBOLIC)

REPORT_PATH = os.path.join(DIR_REPORT, 'test-status.json')
LAST_REPORT_PATH = os.path.join(DIR_LAST_REPORT, 'test-status.json')

if OVERRIDE_LAST:
    DIR_BADGE = os.path.join('data/badges', DIR_LAST_REPORT_REL)
    os.makedirs(DIR_BADGE, exist_ok = True)

    DIR_REDIRECT = os.path.join('gh-pages', DIR_LAST_REPORT_REL)
    os.makedirs(DIR_REDIRECT, exist_ok = True)

################################################################################
# Read current and previous test-status
with open(REPORT_PATH, 'r') as f:
    REPORT = json.load(f)

if os.path.isfile(LAST_REPORT_PATH):
    with open(LAST_REPORT_PATH, 'r') as f:
        LAST_REPORT = json.load(f)
else: # deal with the first run of this script
    LAST_REPORT = {'pkgs': {}, 'hash': 'Unknown'}

REPO = REPORT['repo']

################################################################################
# Generate report.md and test-status-diff.json
REPORT_DIFF = {}
REPORT_DIFF['current'] = REPORT_PATH.split('data/')[1]
REPORT_DIFF['last'] = LAST_REPORT_PATH.split('data/')[1]
REPORT_DIFF['total'] = REPORT['total']
REPORT_DIFF['failure'] = REPORT['failure']
REPORT_DIFF['success'] = REPORT['success']
REPORT_DIFF['skipped'] = REPORT['skipped']

with open(DIR_REPORT+'/report.md', 'w') as f:
    # Header
    f.write('# Package Evaluation Report\n\n')
    f.write('## Job Properties\n\n')
    f.write('*Commits:* %s vs %s\n\n' % (REPORT['hash'], LAST_REPORT['hash']) )
    f.write('*Current Test Status generated by Workflow:* %s\n\n' % REPORT['workflow'])
    f.write('In total, %d packages were tested, out of which %d succeeded, %d failed and %d were skipped.\n\n' % (REPORT['total'], REPORT['success'], REPORT['failure'], REPORT['skipped']))

    PKGS = REPORT['pkgs']
    LAST_PKGS = LAST_REPORT['pkgs']

    ############################################################################
    # New Packages
    PKGS_NEW = [pkg for pkg in PKGS.keys() if
        not pkg in LAST_PKGS.keys()]

    REPORT_DIFF['new'] = len(PKGS_NEW)
    if len(PKGS_NEW) > 0:
        f.write('## New Packages\n\n')
        for pkg in PKGS_NEW:
            status = PKGS[pkg]['status']
            f.write('- %s : %s <br>\n' % (pkg, status))

    ############################################################################
    # Removed Packages
    PKGS_REMOVED = [pkg for pkg in LAST_PKGS.keys() if
        not pkg in PKGS.keys()]

    REPORT_DIFF['removed'] = len(PKGS_REMOVED)
    if len(PKGS_REMOVED) > 0:
        f.write('## Removed Packages\n\n')
        for pkg in PKGS_REMOVED:
            status = LAST_PKGS[pkg]['status']
            f.write('- %s : %s <br>\n' % (pkg, status))

    ############################################################################
    # Changed Status Packages
    for STATUS, STATUS_MSG, STATUS_HEADER in [
                ('failure', 'failed', ':exclamation: Packages now failing'),
                ('success', 'succeeded', ':heavy_check_mark: Packages now succeeding'),
                ('skipped', 'skipped', ':heavy_multiplication_x: Packages that now skipped')]:
        PKGS_FILTERED = [pkg for pkg in PKGS.keys() if
            pkg in LAST_PKGS.keys() and
            PKGS[pkg]['status'] != LAST_PKGS[pkg]['status'] and
            PKGS[pkg]['status'] == STATUS]

        REPORT_DIFF[STATUS+'_changed'] = len(PKGS_FILTERED)
        if len(PKGS_FILTERED) > 0:
            f.write('## %s\n\n' % STATUS_HEADER)
            f.write('%d package(s) %s tests only on the current version.' % (len(PKGS_FILTERED), STATUS_MSG))
            f.write('<details> <summary>Click to expand!</summary>\n\n')
            for pkg in PKGS_FILTERED:
                version = PKGS[pkg]['version']
                last_status = LAST_PKGS[pkg]['status']
                last_version = LAST_PKGS[pkg]['version']
                f.write('- %s %s vs %s %s (%s) <br>\n' % (pkg, version, pkg, last_version, last_status))
            f.write('</details>\n\n')

    ############################################################################
    # Same Status Packages
    for STATUS, STATUS_MSG, STATUS_HEADER in [
                ('failure', 'failed', ':exclamation: Packages still failing'),
                ('success', 'succeeded', ':heavy_check_mark: Packages still succeeding'),
                ('skipped', 'skipped', ':heavy_minus_sign: Packages that still skipped')]:
        PKGS_FILTERED = [pkg for pkg in PKGS.keys() if
            pkg in LAST_PKGS.keys() and
            PKGS[pkg]['status'] == LAST_PKGS[pkg]['status'] and
            PKGS[pkg]['status'] == STATUS]

        REPORT_DIFF[STATUS+'_same'] = len(PKGS_FILTERED)
        if len(PKGS_FILTERED) > 0:
            f.write('## %s\n\n' % STATUS_HEADER)
            f.write('%d package(s) %s tests also on the previous version.' % (len(PKGS_FILTERED), STATUS_MSG))
            f.write('<details> <summary>Click to expand!</summary>\n\n')
            for pkg in PKGS_FILTERED:
                version = PKGS[pkg]['version']
                f.write('- %s %s <br>\n' % (pkg, version))
            f.write('</details>\n\n')

# Write test-status-diff.json
with open(DIR_REPORT+'/test-status-diff.json', 'w') as f:
    json.dump(REPORT_DIFF, f, ensure_ascii=False, indent=2)

################################################################################
# Update Latest
if OVERRIDE_LAST:
    symlink(DIR_REPORT, DIR_LAST_REPORT_SYMBOLIC, overwrite=True)

    ############################################################################
    # Generate html redirect
    with open(os.path.join(DIR_REDIRECT, 'redirect.html'), 'w') as f:
        f.write('''
        <!DOCTYPE html>
        <meta charset="utf-8">
        <title>Redirecting to latest report</title>
        <meta http-equiv="refresh" content="0; URL=%s">
        <link rel="canonical" href="%s">
        ''' % (REPO+'/blob/'+DIR_REPORT+'/report.md', REPO+'/'+DIR_REPORT+'/report.md'))

    ############################################################################
    # Generate badge
    relativeFailures = 1 - REPORT['success'] / REPORT['total']
    if relativeFailures > 0.05:
        color = 'critical'
    elif relativeFailures > 0:
        color = 'important'
    else:
        color = 'success'

    BADGE = {
        'schemaVersion' : 1,
        'label': 'Tests',
        'message': '%d/%d passing' % (REPORT['success'], REPORT['total']),
        'color': color,
        'namedLogo': "github"
    }

    with open(os.path.join(DIR_BADGE, 'badge.json'), 'w') as f:
        json.dump(BADGE, f, ensure_ascii=False, indent=2)